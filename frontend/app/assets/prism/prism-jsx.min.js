!(function (t) {
  const n = t.util.clone(t.languages.javascript);
  let e = '(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})';
  function a(t, n) {
    return (
      (t = t
        .replace(/<S>/g, () => '(?:\\s|//.*(?!.)|/\\*(?:[^*]|\\*(?!/))\\*/)')
        .replace(/<BRACES>/g, () => '(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})')
        .replace(/<SPREAD>/g, () => e)),
      RegExp(t, n)
    );
  }
  (e = a(e).source),
  (t.languages.jsx = t.languages.extend('markup', n)),
  (t.languages.jsx.tag.pattern = a(
    '</?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:"(?:\\\\[^]|[^\\\\"])*"|\'(?:\\\\[^]|[^\\\\\'])*\'|[^\\s{\'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*/?)?>',
  )),
  (t.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/),
  (t.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/),
  (t.languages.jsx.tag.inside.tag.inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/),
  (t.languages.jsx.tag.inside.comment = n.comment),
  t.languages.insertBefore(
    'inside',
    'attr-name',
    { spread: { pattern: a('<SPREAD>'), inside: t.languages.jsx } },
    t.languages.jsx.tag,
  ),
  t.languages.insertBefore(
    'inside',
    'special-attr',
    {
      script: {
        pattern: a('=<BRACES>'),
        alias: 'language-javascript',
        inside: {
          'script-punctuation': { pattern: /^=(?=\{)/, alias: 'punctuation' },
          rest: t.languages.jsx,
        },
      },
    },
    t.languages.jsx.tag,
  );
  const s = function (t) {
    return t
      ? typeof t === 'string'
        ? t
        : typeof t.content === 'string'
          ? t.content
          : t.content.map(s).join('')
      : '';
  };
  const g = function (n) {
    for (let e = [], a = 0; a < n.length; a++) {
      const o = n[a];
      let i = !1;
      if (
        (typeof o !== 'string'
            && (o.type === 'tag' && o.content[0] && o.content[0].type === 'tag'
              ? o.content[0].content[0].content === '</'
                ? e.length > 0
                  && e[e.length - 1].tagName === s(o.content[0].content[1])
                  && e.pop()
                : o.content[o.content.length - 1].content === '/>'
                  || e.push({
                    tagName: s(o.content[0].content[1]),
                    openedBraces: 0,
                  })
              : e.length > 0 && o.type === 'punctuation' && o.content === '{'
                ? e[e.length - 1].openedBraces++
                : e.length > 0
                    && e[e.length - 1].openedBraces > 0
                    && o.type === 'punctuation'
                    && o.content === '}'
                  ? e[e.length - 1].openedBraces--
                  : (i = !0)),
        (i || typeof o === 'string')
            && e.length > 0
            && e[e.length - 1].openedBraces === 0)
      ) {
        let r = s(o);
        a < n.length - 1
            && (typeof n[a + 1] === 'string' || n[a + 1].type === 'plain-text')
            && ((r += s(n[a + 1])), n.splice(a + 1, 1)),
        a > 0
              && (typeof n[a - 1] === 'string' || n[a - 1].type === 'plain-text')
              && ((r = s(n[a - 1]) + r), n.splice(a - 1, 1), a--),
        (n[a] = new t.Token('plain-text', r, null, r));
      }
      o.content && typeof o.content !== 'string' && g(o.content);
    }
  };
  t.hooks.add('after-tokenize', (t) => {
    (t.language !== 'jsx' && t.language !== 'tsx') || g(t.tokens);
  });
}(Prism));
